name: üöÄ Deploy FraudGuard

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'hackathon'
        type: choice
        options:
          - hackathon
          - staging
          - production
      force_rebuild:
        description: 'Force rebuild all images'
        required: false
        default: false
        type: boolean

env:
  PROJECT_ID: fraudguard-hackathon
  REGION: us-central1
  CLUSTER_NAME: fraudguard-auto
  NAMESPACE: fraudguard
  REGISTRY: us-docker.pkg.dev/fraudguard-hackathon/fraudguard

jobs:
  deploy:
    name: üöÄ Build & Deploy FraudGuard
    runs-on: ubuntu-latest

    permissions:
      contents: read
      id-token: write

    steps:
      - name: üì• Checkout Code
        uses: actions/checkout@v4

      - name: üîê Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER_NAME }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT_EMAIL }}

      - name: üõ†Ô∏è Setup Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ env.PROJECT_ID }}
          install_components: 'gke-gcloud-auth-plugin'

      - name: Enable GKE auth plugin
        run: echo "USE_GKE_GCLOUD_AUTH_PLUGIN=True" >> $GITHUB_ENV
      - name: üîß Configure Docker for Artifact Registry
        run: gcloud auth configure-docker us-docker.pkg.dev --quiet

      - name: üèóÔ∏è Build and Push All Images
        run: |
          echo "üèóÔ∏è Building all FraudGuard services..."

          # Build all services
          services=("mcp-gateway" "txn-watcher" "risk-scorer" "explain-agent" "action-orchestrator" "boa-monitor")

          for service in "${services[@]}"; do
            echo "üî® Building $service..."
            docker build -t ${{ env.REGISTRY }}/$service:${{ github.sha }} services/$service/
            docker push ${{ env.REGISTRY }}/$service:${{ github.sha }}

            # Also tag as latest for this environment
            docker tag ${{ env.REGISTRY }}/$service:${{ github.sha }} ${{ env.REGISTRY }}/$service:${{ inputs.environment }}
            docker push ${{ env.REGISTRY }}/$service:${{ inputs.environment }}
          done

          # Build dashboard
          echo "üî® Building dashboard..."
          docker build -t ${{ env.REGISTRY }}/dashboard:${{ github.sha }} web/dashboard/
          docker push ${{ env.REGISTRY }}/dashboard:${{ github.sha }}

          docker tag ${{ env.REGISTRY }}/dashboard:${{ github.sha }} ${{ env.REGISTRY }}/dashboard:${{ inputs.environment }}
          docker push ${{ env.REGISTRY }}/dashboard:${{ inputs.environment }}

      - name: üéØ Get GKE Credentials
        run: |
          gcloud container clusters get-credentials ${{ env.CLUSTER_NAME }} \
            --region ${{ env.REGION }} \
            --project ${{ env.PROJECT_ID }}

      - name: Install Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.12.0'

      - name: üì¶ Deploy to Kubernetes
        run: |
          echo "üöÄ Deploying FraudGuard to Kubernetes..."

          # Create namespace if it doesn't exist
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

          # Update image tags in values files
          services=("mcp-gateway" "txn-watcher" "risk-scorer" "explain-agent" "action-orchestrator" "dashboard" "boa-monitor")

          for service in "${services[@]}"; do
            echo "üì¶ Deploying $service..."

            # Update the image tag in values file (only the image.tag line)
            sed -i "s|^\([[:space:]]*tag:\).*|\1 ${{ inputs.environment }}|g" values/$service.yaml

            # Deploy using Helm (longer timeout, atomic rollback, and diagnostics on failure)
            if ! helm upgrade --install "$service" ./helm/workload \
              -f "values/$service.yaml" \
              -n "${{ env.NAMESPACE }}" \
              --atomic --wait --timeout=600s; then
              echo "‚ùå Helm failed for $service ‚Äì collecting diagnostics..."
              kubectl get pods -n "${{ env.NAMESPACE }}" -o wide || true
              kubectl describe deploy/"$service" -n "${{ env.NAMESPACE }}" || true
              kubectl describe pods -n "${{ env.NAMESPACE }}" | tail -n +1 || true
              exit 1
            fi
          done

          # Deploy external LoadBalancer services for IP access
          echo "üåê Deploying external LoadBalancer services..."
          kubectl apply -f k8s/external-services.yaml

      - name: üßπ Cleanup test pods
        run: |
          echo "Cleaning up test pods (curl-boa) if present..."
          kubectl delete pod -n ${{ env.NAMESPACE }} curl-boa --ignore-not-found=true

      - name: ‚úÖ Verify Deployment
        run: |
          echo "üîç Verifying deployment..."

          # Wait for all pods to be ready
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=mcp-gateway -n ${{ env.NAMESPACE }} --timeout=300s
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/instance=dashboard -n ${{ env.NAMESPACE }} --timeout=300s

          # Check pod status
          echo "üìä Pod Status:"
          kubectl get pods -n ${{ env.NAMESPACE }}

          # Check service status
          echo "üåê Service Status:"
          kubectl get svc -n ${{ env.NAMESPACE }}

          # Check external LoadBalancer IPs
          echo "üåç External LoadBalancer Services:"
          kubectl get svc -n ${{ env.NAMESPACE }} -l service=external-access
          kubectl get svc -n boa -l service=external-access

      - name: üß™ Health Check
        run: |
          echo "üè• Running health checks..."

          # Port forward for health checks
          kubectl port-forward -n ${{ env.NAMESPACE }} svc/dashboard 8080:8080 &
          PF1=$!
          kubectl port-forward -n ${{ env.NAMESPACE }} svc/mcp-gateway 8082:8080 &
          PF2=$!

          sleep 10

          # Test dashboard health
          if curl -f http://localhost:8080/healthz; then
            echo "‚úÖ Dashboard health check passed"
          else
            echo "‚ùå Dashboard health check failed"
            kill $PF1 $PF2 || true
            exit 1
          fi

          # Test MCP Gateway health
          if curl -f http://localhost:8082/healthz; then
            echo "‚úÖ MCP Gateway health check passed"
          else
            echo "‚ùå MCP Gateway health check failed"
            kill $PF1 $PF2 || true
            exit 1
          fi

      - name: ü§ñ E2E Smoke Test
        run: |
          echo "üö¶ Starting E2E smoke: seed transaction via MCP Gateway and verify on Dashboard"

          TXID="ci_smoke_$(date +%s)"
          NOW=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          echo "Submitting synthetic transaction $TXID"
          curl -sS -X POST http://localhost:8082/api/transactions \
            -H "Content-Type: application/json" \
            -d "{\"transaction_id\": \"$TXID\", \"amount\": 42.50, \"merchant\": \"SmokeTest Cafe\", \"user_id\": \"user-ci\", \"timestamp\": \"$NOW\"}" | tee /tmp/tx_submit.json

          echo "Polling dashboard for presence of $TXID ..."
          ATTEMPTS=24
          SLEEP=5
          FOUND=0
          for i in $(seq 1 $ATTEMPTS); do
            BODY=$(curl -sSf http://localhost:8080/api/records || true)
            if echo "$BODY" | grep -q "$TXID"; then
              echo "‚úÖ Found transaction on dashboard (attempt $i)"
              FOUND=1
              break
            fi
            echo "...not yet (attempt $i/$ATTEMPTS). Sleeping $SLEEP s"
            sleep $SLEEP
          done

          # Always best-effort kill port-forwards after test
          pkill -f 'kubectl port-forward' || true

          if [ "$FOUND" -ne 1 ]; then
            echo "‚ùå E2E smoke failed: transaction $TXID not visible on dashboard"
            exit 1
          fi

          echo "‚úÖ E2E smoke passed"

      - name: üìù Deployment Summary
        run: |
          echo "üéâ FraudGuard Deployment Complete!"
          echo ""
          echo "üìä Deployment Details:"
          echo "Environment: ${{ inputs.environment }}"
          echo "Commit SHA: ${{ github.sha }}"
          echo "Namespace: ${{ env.NAMESPACE }}"
          echo ""
          echo "üåê Access URLs (via port-forward):"
          echo "Dashboard: kubectl port-forward -n ${{ env.NAMESPACE }} svc/dashboard 8080:8080"
          echo "MCP Gateway: kubectl port-forward -n ${{ env.NAMESPACE }} svc/mcp-gateway 8082:8080"
          echo "Bank of Anthos: kubectl port-forward -n boa svc/frontend 8081:80"
          echo ""
          echo "üîó External IP Access:"
          echo "Get external IPs with: kubectl get svc -l service=external-access --all-namespaces"
          echo ""
          echo "üì± Access via External IPs:"
          echo "FraudGuard Dashboard: http://[EXTERNAL-IP]/"
          echo "FraudGuard API: http://[API-EXTERNAL-IP]/api/"
          echo "Bank of Anthos: http://[BOA-EXTERNAL-IP]/"
          echo ""
          echo "üîó Domain URLs (if configured):"
          echo "FraudGuard: https://fraudguard.mohankrishna.site"
          echo "Bank of Anthos: https://boa.mohankrishna.site"
